"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6084],{5152:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"microfrontends-concept","title":"Microfrontends Overview","description":"Tutorial video: Youtube / Bilibili","source":"@site/versioned_docs/version-5.x/microfrontends-concept.md","sourceDirName":".","slug":"/microfrontends-concept","permalink":"/docs/5.x/microfrontends-concept","draft":false,"unlisted":false,"editUrl":"https://github.com/single-spa/single-spa.js.org/blob/master/website/versioned_docs/version-5.x/microfrontends-concept.md","tags":[],"version":"5.x","frontMatter":{"id":"microfrontends-concept","title":"Microfrontends Overview","sidebar_label":"Overview"},"sidebar":"docs","previous":{"title":"Shared Webpack configs","permalink":"/docs/5.x/shared-webpack-configs"},"next":{"title":"Microfrontend Types","permalink":"/docs/5.x/module-types"}}');var t=o(4848),r=o(8453);const s={id:"microfrontends-concept",title:"Microfrontends Overview",sidebar_label:"Overview"},c="Concept: Microfrontends",a={},d=[{value:"Comparison to Microservices",id:"comparison-to-microservices",level:2},{value:"Concrete Technical Definition",id:"concrete-technical-definition",level:2},{value:"Types of Microfrontends",id:"types-of-microfrontends",level:2},{value:"Communication between Microfrontends",id:"communication-between-microfrontends",level:2},{value:"Relationship to single-spa",id:"relationship-to-single-spa",level:2},{value:"Performance",id:"performance",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"concept-microfrontends",children:"Concept: Microfrontends"})}),"\n",(0,t.jsxs)(n.p,{children:["Tutorial video: ",(0,t.jsx)(n.a,{href:"https://www.youtube.com/watch?v=3EUfbnHi6Wg&list=PLLUD8RtHvsAOhtHnyGx57EYXoaNsxGrTU&index=1",children:"Youtube"})," / ",(0,t.jsx)(n.a,{href:"https://www.bilibili.com/video/av83619684",children:"Bilibili"})]}),"\n",(0,t.jsx)(n.p,{children:"A microfrontend is a microservice that exists within a browser."}),"\n",(0,t.jsx)(n.p,{children:"Microfrontends are sections of your UI, often consisting of dozens of components, that use frameworks like React, Vue, and Angular to render their components. Each microfrontend can be managed by a different team and may be implemented using its own framework. It is practical and suggested to use just one framework for all your microfrontends, although you may add additional frameworks when migrating or when experimenting."}),"\n",(0,t.jsxs)(n.p,{children:["Each microfrontend has its own git repository, its own ",(0,t.jsx)(n.code,{children:"package.json"})," file, and its own build tool configuration. As a result, each microfrontend has ",(0,t.jsx)(n.strong,{children:"an independent build process"})," and ",(0,t.jsx)(n.strong,{children:"an independent deploy / CI"}),". This generally means that each repo has fast build times."]}),"\n",(0,t.jsx)(n.h2,{id:"comparison-to-microservices",children:"Comparison to Microservices"}),"\n",(0,t.jsx)(n.p,{children:"Microservices are backend services that run in their own operating system process, control their own databases, and communicate with each other over the network."}),"\n",(0,t.jsx)(n.p,{children:"Compare that to microfrontends that all exist within a single browser tab: all browser JavaScript within a tab exists in a single operating system process (and even thread!). Browser JavaScript generally does not directly access databases, and communication within a browser tab happens in-memory instead of over the network."}),"\n",(0,t.jsx)(n.p,{children:"So what do they have in common???"}),"\n",(0,t.jsx)(n.p,{children:"Independent builds and deployments. Think of the DOM as the shared resource that your microfrontends are owning. One microfrontend's DOM should not be touched by another microfrontend, similar to how one backend microservice's database should not be touched by any microservice except the one that owns/controls it."}),"\n",(0,t.jsx)(n.h2,{id:"concrete-technical-definition",children:"Concrete Technical Definition"}),"\n",(0,t.jsxs)(n.p,{children:["In the context of single-spa, a microfrontend is often an in-browser JavaScript module. You can read more about this ",(0,t.jsx)(n.a,{href:"/docs/recommended-setup#in-browser-versus-build-time-modules",children:"in the recommended setup"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"types-of-microfrontends",children:"Types of Microfrontends"}),"\n",(0,t.jsx)(n.p,{children:"In the context of single-spa, there are three kinds of microfrontends:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/building-applications",children:"single-spa applications"}),": Microfrontends that render components for a set of specific routes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/parcels-overview",children:"single-spa parcels"}),": Microfrontends that render components without controlling routes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"/docs/recommended-setup#utility-modules-styleguide-api-etc",children:"utility modules"}),": Microfrontends that export shared JavaScript logic without rendering components."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["A web app may include one or more types of microfrontends. See ",(0,t.jsx)(n.a,{href:"/docs/module-types",children:"an in-depth comparison"})," and our recommendations for ",(0,t.jsx)(n.a,{href:"/docs/recommended-setup#applications-versus-parcels-versus-utility-modules",children:"choosing between microfrontend types"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"communication-between-microfrontends",children:"Communication between Microfrontends"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"import { thing } from 'other-microfrontend'"})," is the preferred way to communicate between microfrontends. ",(0,t.jsx)(n.a,{href:"/docs/recommended-setup#inter-app-communication",children:"Here is some documentation"})," that goes over this in more detail."]}),"\n",(0,t.jsx)(n.h2,{id:"relationship-to-single-spa",children:"Relationship to single-spa"}),"\n",(0,t.jsxs)(n.p,{children:["single-spa is a small, 5kb (gzipped) npm package that orchestrates the mounting and unmounting of your microfrontends. It knows when to mount the applications based on ",(0,t.jsx)(n.a,{href:"/docs/api/#registerapplication",children:"activity functions"})," and can do so in a framework agnostic way with the help of small ",(0,t.jsx)(n.a,{href:"/docs/ecosystem",children:"adapter libraries"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,t.jsxs)(n.p,{children:["Microfrontends are often more performant than the monoliths from which they originate. This is due to built-in lazy loading (via ",(0,t.jsx)(n.a,{href:"/docs/api/#registerapplication",children:"loading functions"}),') and other performance-related best practices. Your monolith likely has "skeletons in its closet" - microfrontends gives you a migration path that will expose and resolve the problems caused by those skeletons. One important performance consideration is to share a single instance of large libraries (such as React, Vue, or Angular), which is highly encouraged. To do so, see our ',(0,t.jsx)(n.a,{href:"/docs/recommended-setup#shared-dependencies",children:"recommended setup"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>c});var i=o(6540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);